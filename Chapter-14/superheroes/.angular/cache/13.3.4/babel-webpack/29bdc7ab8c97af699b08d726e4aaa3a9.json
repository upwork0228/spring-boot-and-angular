{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { INIT, UPDATE, ActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\n\nclass StoreDevtoolsConfig {\n  constructor() {\n    /**\n     * Maximum allowed actions to be stored in the history tree (default: `false`)\n     */\n    this.maxAge = false;\n  }\n\n}\n\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\n\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\n\nfunction noMonitor() {\n  return null;\n}\n\nconst DEFAULT_NAME = 'NgRx Store DevTools';\n\nfunction createConfig(optionsInput) {\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      lock: true,\n      persist: true,\n      export: true,\n      import: 'custom',\n      jump: true,\n      skip: true,\n      reorder: true,\n      dispatch: true,\n      test: true // Generate tests for the selected actions\n\n    }\n  };\n  const options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  const config = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n  }\n\n  return config;\n}\n\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nclass PerformAction {\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n  }\n\n}\n\nclass Refresh {\n  constructor() {\n    this.type = REFRESH;\n  }\n\n}\n\nclass Reset {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n\n}\n\nclass Rollback {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n\n}\n\nclass Commit {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n\n}\n\nclass Sweep {\n  constructor() {\n    this.type = SWEEP;\n  }\n\n}\n\nclass ToggleAction {\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n\n}\n\nclass SetActionsActive {\n  constructor(start, end, active = true) {\n    this.start = start;\n    this.end = end;\n    this.active = active;\n    this.type = SET_ACTIONS_ACTIVE;\n  }\n\n}\n\nclass JumpToState {\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n\n}\n\nclass JumpToAction {\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n\n}\n\nclass ImportState {\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n\n}\n\nclass LockChanges {\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n\n}\n\nclass PauseRecording {\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n\n}\n\nfunction difference(first, second) {\n  return first.filter(item => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState; // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state\n    } = computedStates[computedStates.length - 1];\n    return state;\n  }\n\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\n\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\n\n\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\n\n\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign(Object.assign({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n */\n\n\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\n/**\n * Sanitizes given state with given function.\n */\n\n\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\n\n\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\n\n\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  const filteredStagedActionIds = [];\n  const filteredActionsById = {};\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign(Object.assign({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n */\n\n\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch = safelist && !action.action.type.match(safelist.map(s => escapeRegExp(s)).join('|'));\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(s => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nconst INIT_ACTION = {\n  type: INIT\n};\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n */\n\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n\n  let nextState = state;\n  let nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex); // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  } // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n\n\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return reducer => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(id => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function commitChanges() {\n      // Consider the last committed state the new starting point.\n      // Squash any staged actions into a single committed state.\n      actionsById = {\n        0: liftAction(INIT_ACTION)\n      };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    } // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n\n    let minInvalidatedStateIndex = 0;\n\n    switch (liftedAction.type) {\n      case LOCK_CHANGES:\n        {\n          isLocked = liftedAction.status;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n\n      case PAUSE_RECORDING:\n        {\n          isPaused = liftedAction.status;\n\n          if (isPaused) {\n            // Add a pause action to signal the devtools-user the recording is paused.\n            // The corresponding state will be overwritten on each update to always contain\n            // the latest state (see Actions.PERFORM_ACTION).\n            stagedActionIds = [...stagedActionIds, nextActionId];\n            actionsById[nextActionId] = new PerformAction({\n              type: '@ngrx/devtools/pause'\n            }, +Date.now());\n            nextActionId++;\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n\n            if (currentStateIndex === stagedActionIds.length - 2) {\n              currentStateIndex++;\n            }\n\n            minInvalidatedStateIndex = Infinity;\n          } else {\n            commitChanges();\n          }\n\n          break;\n        }\n\n      case RESET:\n        {\n          // Get back to the state the store was created with.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          committedState = initialCommittedState;\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n\n      case COMMIT:\n        {\n          commitChanges();\n          break;\n        }\n\n      case ROLLBACK:\n        {\n          // Forget about any staged actions.\n          // Start again from the last committed state.\n          actionsById = {\n            0: liftAction(INIT_ACTION)\n          };\n          nextActionId = 1;\n          stagedActionIds = [0];\n          skippedActionIds = [];\n          currentStateIndex = 0;\n          computedStates = [];\n          break;\n        }\n\n      case TOGGLE_ACTION:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            id: actionId\n          } = liftedAction;\n          const index = skippedActionIds.indexOf(actionId);\n\n          if (index === -1) {\n            skippedActionIds = [actionId, ...skippedActionIds];\n          } else {\n            skippedActionIds = skippedActionIds.filter(id => id !== actionId);\n          } // Optimization: we know history before this action hasn't changed\n\n\n          minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n          break;\n        }\n\n      case SET_ACTIONS_ACTIVE:\n        {\n          // Toggle whether an action with given ID is skipped.\n          // Being skipped means it is a no-op during the computation.\n          const {\n            start,\n            end,\n            active\n          } = liftedAction;\n          const actionIds = [];\n\n          for (let i = start; i < end; i++) actionIds.push(i);\n\n          if (active) {\n            skippedActionIds = difference(skippedActionIds, actionIds);\n          } else {\n            skippedActionIds = [...skippedActionIds, ...actionIds];\n          } // Optimization: we know history before this action hasn't changed\n\n\n          minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n          break;\n        }\n\n      case JUMP_TO_STATE:\n        {\n          // Without recomputing anything, move the pointer that tell us\n          // which state is considered the current one. Useful for sliders.\n          currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n\n      case JUMP_TO_ACTION:\n        {\n          // Jumps to a corresponding state to a specific action.\n          // Useful when filtering actions.\n          const index = stagedActionIds.indexOf(liftedAction.actionId);\n          if (index !== -1) currentStateIndex = index;\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n\n      case SWEEP:\n        {\n          // Forget any actions that are currently being skipped.\n          stagedActionIds = difference(stagedActionIds, skippedActionIds);\n          skippedActionIds = [];\n          currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n          break;\n        }\n\n      case PERFORM_ACTION:\n        {\n          // Ignore action and return state as is if recording is locked\n          if (isLocked) {\n            return liftedState || initialLiftedState;\n          }\n\n          if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n            // If recording is paused or if the action should be ignored, overwrite the last state\n            // (corresponds to the pause action) and keep everything else as is.\n            // This way, the app gets the new current state while the devtools\n            // do not record another action.\n            const lastState = computedStates[computedStates.length - 1];\n            computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)];\n            minInvalidatedStateIndex = Infinity;\n            break;\n          } // Auto-commit as new actions come in.\n\n\n          if (options.maxAge && stagedActionIds.length === options.maxAge) {\n            commitExcessActions(1);\n          }\n\n          if (currentStateIndex === stagedActionIds.length - 1) {\n            currentStateIndex++;\n          }\n\n          const actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n          // It is safe because we set a new key in a cache dictionary.\n\n          actionsById[actionId] = liftedAction;\n          stagedActionIds = [...stagedActionIds, actionId]; // Optimization: we know that only the new action needs computing.\n\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          break;\n        }\n\n      case IMPORT_STATE:\n        {\n          // Completely replace everything.\n          ({\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused\n          } = liftedAction.nextLiftedState);\n          break;\n        }\n\n      case INIT:\n        {\n          // Always recompute states on hot reload and init.\n          minInvalidatedStateIndex = 0;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n            minInvalidatedStateIndex = Infinity;\n          }\n\n          break;\n        }\n\n      case UPDATE:\n        {\n          const stateHasErrors = computedStates.filter(state => state.error).length > 0;\n\n          if (stateHasErrors) {\n            // Recompute all states\n            minInvalidatedStateIndex = 0;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n              minInvalidatedStateIndex = Infinity;\n            }\n          } else {\n            // If not paused/locked, add a new action to signal devtools-user\n            // that there was a reducer update.\n            if (!isPaused && !isLocked) {\n              if (currentStateIndex === stagedActionIds.length - 1) {\n                currentStateIndex++;\n              } // Add a new action to only recompute state\n\n\n              const actionId = nextActionId++;\n              actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n              stagedActionIds = [...stagedActionIds, actionId];\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n            } // Recompute state history with latest reducer and update action\n\n\n            computedStates = computedStates.map(cmp => Object.assign(Object.assign({}, cmp), {\n              state: reducer(cmp.state, RECOMPUTE_ACTION)\n            }));\n            currentStateIndex = stagedActionIds.length - 1;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              commitExcessActions(stagedActionIds.length - options.maxAge);\n            } // Avoid double computation.\n\n\n            minInvalidatedStateIndex = Infinity;\n          }\n\n          break;\n        }\n\n      default:\n        {\n          // If the action is not recognized, it's a monitor action.\n          // Optimization: a monitor action can't change history.\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\n\nclass DevtoolsDispatcher extends ActionsSubject {}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nDevtoolsDispatcher.ɵfac = /* @__PURE__ */function () {\n  let ɵDevtoolsDispatcher_BaseFactory;\n  return function DevtoolsDispatcher_Factory(t) {\n    return (ɵDevtoolsDispatcher_BaseFactory || (ɵDevtoolsDispatcher_BaseFactory = i0.ɵɵgetInheritedFactory(DevtoolsDispatcher)))(t || DevtoolsDispatcher);\n  };\n}();\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nDevtoolsDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DevtoolsDispatcher,\n  factory: DevtoolsDispatcher.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DevtoolsDispatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nconst ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\n\nclass DevtoolsExtension {\n  constructor(devtoolsExtension, config, dispatcher) {\n    this.config = config;\n    this.dispatcher = dispatcher;\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n\n  notify(action, state) {\n    if (!this.devtoolsExtension) {\n      return;\n    } // Check to see if the action requires a full update of the liftedState.\n    // If it is a simple action generated by the user's app and the recording\n    // is not locked/paused, only send the action and the current state (fast).\n    //\n    // A full liftedState update (slow: serializes the entire liftedState) is\n    // only required when:\n    //   a) redux-devtools-extension fires the @@Init action (ignored by\n    //      @ngrx/store-devtools)\n    //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n    //      or @ngrx/store/update-reducers)\n    //   c) the state has been recomputed due to time-traveling\n    //   d) any action that is not a PerformAction to err on the side of\n    //      caution.\n\n\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n\n      const currentState = unliftState(state);\n\n      if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n        return;\n      }\n\n      const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n      const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n      this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n    } else {\n      // Requires full state update\n      const sanitizedLiftedState = Object.assign(Object.assign({}, state), {\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n        computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n      });\n      this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n    }\n  }\n\n  createChangesObservable() {\n    if (!this.devtoolsExtension) {\n      return EMPTY;\n    }\n\n    return new Observable(subscriber => {\n      const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n      this.extensionConnection = connection;\n      connection.init();\n      connection.subscribe(change => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n\n  createActionStreams() {\n    // Listens to all changes\n    const changes$ = this.createChangesObservable().pipe(share()); // Listen for the start action\n\n    const start$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.START)); // Listen for the stop action\n\n    const stop$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.STOP)); // Listen for lifted actions\n\n    const liftedActions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.DISPATCH), map(change => this.unwrapAction(change.payload)), concatMap(action => {\n      if (action.type === IMPORT_STATE) {\n        // State imports may happen in two situations:\n        // 1. Explicitly by user\n        // 2. User activated the \"persist state accross reloads\" option\n        //    and now the state is imported during reload.\n        // Because of option 2, we need to give possible\n        // lazy loaded reducers time to instantiate.\n        // As soon as there is no UPDATE action within 1 second,\n        // it is assumed that all reducers are loaded.\n        return this.dispatcher.pipe(filter(action => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n      } else {\n        return of(action);\n      }\n    })); // Listen for unlifted actions\n\n    const actions$ = changes$.pipe(filter(change => change.type === ExtensionActionTypes.ACTION), map(change => this.unwrapAction(change.payload)));\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$)); // Only take the action sources between the start/stop events\n\n    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n  }\n\n  unwrapAction(action) {\n    return typeof action === 'string' ? eval(`(${action})`) : action;\n  }\n\n  getExtensionConfig(config) {\n    var _a;\n\n    const extensionOptions = {\n      name: config.name,\n      features: config.features,\n      serialize: config.serialize,\n      autoPause: (_a = config.autoPause) !== null && _a !== void 0 ? _a : false // The action/state sanitizers are not added to the config\n      // because sanitation is done in this class already.\n      // It is done before sending it to the devtools extension for consistency:\n      // - If we call extensionConnection.send(...),\n      //   the extension would call the sanitizers.\n      // - If we call devtoolsExtension.send(...) (aka full state update),\n      //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n\n    };\n\n    if (config.maxAge !== false\n    /* support === 0 */\n    ) {\n      extensionOptions.maxAge = config.maxAge;\n    }\n\n    return extensionOptions;\n  }\n\n  sendToReduxDevtools(send) {\n    try {\n      send();\n    } catch (err) {\n      console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n    }\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nDevtoolsExtension.ɵfac = function DevtoolsExtension_Factory(t) {\n  return new (t || DevtoolsExtension)(i0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG), i0.ɵɵinject(DevtoolsDispatcher));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nDevtoolsExtension.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DevtoolsExtension,\n  factory: DevtoolsExtension.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DevtoolsExtension, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [REDUX_DEVTOOLS_EXTENSION]\n      }]\n    }, {\n      type: StoreDevtoolsConfig,\n      decorators: [{\n        type: Inject,\n        args: [STORE_DEVTOOLS_CONFIG]\n      }]\n    }, {\n      type: DevtoolsDispatcher\n    }];\n  }, null);\n})();\n\nclass StoreDevtools {\n  constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n    const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n    const liftedStateSubject = new ReplaySubject(1);\n    const liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(({\n      state: liftedState\n    }, [action, reducer]) => {\n      let reducedLiftedState = reducer(liftedState, action); // On full state update\n      // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n\n      if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n        reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n      } // Extension should be sent the sanitized lifted state\n\n\n      extension.notify(action, reducedLiftedState);\n      return {\n        state: reducedLiftedState,\n        action\n      };\n    }, {\n      state: liftedInitialState,\n      action: null\n    })).subscribe(({\n      state,\n      action\n    }) => {\n      liftedStateSubject.next(state);\n\n      if (action.type === PERFORM_ACTION) {\n        const unliftedAction = action.action;\n        scannedActions.next(unliftedAction);\n      }\n    });\n    const extensionStartSubscription = extension.start$.subscribe(() => {\n      this.refresh();\n    });\n    const liftedState$ = liftedStateSubject.asObservable();\n    const state$ = liftedState$.pipe(map(unliftState));\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n\n  dispatch(action) {\n    this.dispatcher.next(action);\n  }\n\n  next(action) {\n    this.dispatcher.next(action);\n  }\n\n  error(error) {}\n\n  complete() {}\n\n  performAction(action) {\n    this.dispatch(new PerformAction(action, +Date.now()));\n  }\n\n  refresh() {\n    this.dispatch(new Refresh());\n  }\n\n  reset() {\n    this.dispatch(new Reset(+Date.now()));\n  }\n\n  rollback() {\n    this.dispatch(new Rollback(+Date.now()));\n  }\n\n  commit() {\n    this.dispatch(new Commit(+Date.now()));\n  }\n\n  sweep() {\n    this.dispatch(new Sweep());\n  }\n\n  toggleAction(id) {\n    this.dispatch(new ToggleAction(id));\n  }\n\n  jumpToAction(actionId) {\n    this.dispatch(new JumpToAction(actionId));\n  }\n\n  jumpToState(index) {\n    this.dispatch(new JumpToState(index));\n  }\n\n  importState(nextLiftedState) {\n    this.dispatch(new ImportState(nextLiftedState));\n  }\n\n  lockChanges(status) {\n    this.dispatch(new LockChanges(status));\n  }\n\n  pauseRecording(status) {\n    this.dispatch(new PauseRecording(status));\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nStoreDevtools.ɵfac = function StoreDevtools_Factory(t) {\n  return new (t || StoreDevtools)(i0.ɵɵinject(DevtoolsDispatcher), i0.ɵɵinject(i2.ActionsSubject), i0.ɵɵinject(i2.ReducerObservable), i0.ɵɵinject(DevtoolsExtension), i0.ɵɵinject(i2.ScannedActionsSubject), i0.ɵɵinject(i0.ErrorHandler), i0.ɵɵinject(INITIAL_STATE), i0.ɵɵinject(STORE_DEVTOOLS_CONFIG));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nStoreDevtools.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StoreDevtools,\n  factory: StoreDevtools.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoreDevtools, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DevtoolsDispatcher\n    }, {\n      type: i2.ActionsSubject\n    }, {\n      type: i2.ReducerObservable\n    }, {\n      type: DevtoolsExtension\n    }, {\n      type: i2.ScannedActionsSubject\n    }, {\n      type: i0.ErrorHandler\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [INITIAL_STATE]\n      }]\n    }, {\n      type: StoreDevtoolsConfig,\n      decorators: [{\n        type: Inject,\n        args: [STORE_DEVTOOLS_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\n\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nfunction createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (typeof window === 'object' && typeof window[extensionKey] !== 'undefined') {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\n\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n\nclass StoreDevtoolsModule {\n  static instrument(options = {}) {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n        provide: INITIAL_OPTIONS,\n        useValue: options\n      }, {\n        provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n        deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n        useFactory: createIsExtensionOrMonitorPresent\n      }, {\n        provide: REDUX_DEVTOOLS_EXTENSION,\n        useFactory: createReduxDevtoolsExtension\n      }, {\n        provide: STORE_DEVTOOLS_CONFIG,\n        deps: [INITIAL_OPTIONS],\n        useFactory: createConfig\n      }, {\n        provide: StateObservable,\n        deps: [StoreDevtools],\n        useFactory: createStateObservable\n      }, {\n        provide: ReducerManagerDispatcher,\n        useExisting: DevtoolsDispatcher\n      }]\n    };\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nStoreDevtoolsModule.ɵfac = function StoreDevtoolsModule_Factory(t) {\n  return new (t || StoreDevtoolsModule)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nStoreDevtoolsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: StoreDevtoolsModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\n\nStoreDevtoolsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StoreDevtoolsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { INITIAL_OPTIONS, RECOMPUTE, REDUX_DEVTOOLS_EXTENSION, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule };","map":{"version":3,"sources":["/Users/devlinduldulao/Desktop/Books/Full-Stack-Web-Development-with-Spring-Boot-and-Angular/Chapter-14/superheroes/node_modules/@ngrx/store-devtools/fesm2015/ngrx-store-devtools.mjs"],"names":["i0","InjectionToken","Injectable","Inject","NgModule","i2","INIT","UPDATE","ActionsSubject","INITIAL_STATE","StateObservable","ReducerManagerDispatcher","EMPTY","Observable","of","merge","queueScheduler","ReplaySubject","share","filter","map","concatMap","timeout","debounceTime","catchError","take","takeUntil","switchMap","skip","observeOn","withLatestFrom","scan","StoreDevtoolsConfig","constructor","maxAge","STORE_DEVTOOLS_CONFIG","INITIAL_OPTIONS","noMonitor","DEFAULT_NAME","createConfig","optionsInput","DEFAULT_OPTIONS","monitor","actionSanitizer","undefined","stateSanitizer","name","serialize","logOnly","autoPause","features","pause","lock","persist","export","import","jump","reorder","dispatch","test","options","config","Object","assign","Error","PERFORM_ACTION","REFRESH","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","PerformAction","action","timestamp","type","Refresh","Reset","Rollback","Commit","Sweep","ToggleAction","id","SetActionsActive","start","end","active","JumpToState","index","JumpToAction","actionId","ImportState","nextLiftedState","LockChanges","status","PauseRecording","difference","first","second","item","indexOf","unliftState","liftedState","computedStates","currentStateIndex","length","state","unliftAction","actionsById","nextActionId","liftAction","Date","now","sanitizeActions","actions","keys","reduce","sanitizedActions","actionIdx","idx","Number","sanitizeAction","sanitizeStates","states","computedState","sanitizeState","error","stateIdx","shouldFilterActions","predicate","actionsSafelist","actionsBlocklist","filterLiftedState","safelist","blocklist","filteredStagedActionIds","filteredActionsById","filteredComputedStates","stagedActionIds","forEach","liftedAction","isActionFiltered","push","blockedlist","predicateMatch","safelistMatch","match","s","escapeRegExp","join","blocklistMatch","replace","INIT_ACTION","RECOMPUTE","RECOMPUTE_ACTION","computeNextEntry","reducer","errorHandler","nextState","nextError","err","toString","handleError","recomputeStates","minInvalidatedStateIndex","committedState","skippedActionIds","isPaused","nextComputedStates","slice","lastIncludedActionId","i","previousEntry","previousState","previousError","shouldSkip","entry","liftInitialState","initialCommittedState","monitorReducer","monitorState","isLocked","liftReducerWith","initialLiftedState","create","commitExcessActions","n","excess","idsToDelete","commitChanges","Infinity","concat","actionIds","Math","min","lastState","stateHasErrors","cmp","DevtoolsDispatcher","ɵfac","ɵprov","ExtensionActionTypes","START","DISPATCH","STOP","ACTION","REDUX_DEVTOOLS_EXTENSION","DevtoolsExtension","devtoolsExtension","dispatcher","createActionStreams","notify","currentState","sanitizedState","sanitizedAction","sendToReduxDevtools","extensionConnection","send","sanitizedLiftedState","getExtensionConfig","createChangesObservable","subscriber","connection","connect","init","subscribe","change","next","unsubscribe","changes$","pipe","start$","stop$","liftedActions$","unwrapAction","payload","actions$","actionsUntilStop$","liftedUntilStop$","eval","_a","extensionOptions","console","warn","decorators","args","StoreDevtools","reducers$","extension","scannedActions","initialState","liftedInitialState","liftReducer","liftedAction$","asObservable","liftedReducer$","liftedStateSubject","liftedStateSubscription","reducedLiftedState","unliftedAction","extensionStartSubscription","refresh","liftedState$","state$","stateSubscription","complete","performAction","reset","rollback","commit","sweep","toggleAction","jumpToAction","jumpToState","importState","lockChanges","pauseRecording","ReducerObservable","ScannedActionsSubject","ErrorHandler","IS_EXTENSION_OR_MONITOR_PRESENT","createIsExtensionOrMonitorPresent","Boolean","createReduxDevtoolsExtension","extensionKey","window","createStateObservable","devtools","StoreDevtoolsModule","instrument","ngModule","providers","provide","useValue","deps","useFactory","useExisting","ɵmod","ɵinj"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, NgModule } from '@angular/core';\nimport * as i2 from '@ngrx/store';\nimport { INIT, UPDATE, ActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n\n/**\n * Chrome extension documentation\n * @see https://github.com/reduxjs/redux-devtools/blob/main/extension/docs/API/Arguments.md\n * Firefox extension documentation\n * @see https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/API/Arguments.md\n */\nclass StoreDevtoolsConfig {\n    constructor() {\n        /**\n         * Maximum allowed actions to be stored in the history tree (default: `false`)\n         */\n        this.maxAge = false;\n    }\n}\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\n/**\n * Used to provide a `StoreDevtoolsConfig` for the store-devtools.\n */\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\nfunction noMonitor() {\n    return null;\n}\nconst DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(optionsInput) {\n    const DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n        actionSanitizer: undefined,\n        stateSanitizer: undefined,\n        name: DEFAULT_NAME,\n        serialize: false,\n        logOnly: false,\n        autoPause: false,\n        // Add all features explicitly. This prevent buggy behavior for\n        // options like \"lock\" which might otherwise not show up.\n        features: {\n            pause: true,\n            lock: true,\n            persist: true,\n            export: true,\n            import: 'custom',\n            jump: true,\n            skip: true,\n            reorder: true,\n            dispatch: true,\n            test: true, // Generate tests for the selected actions\n        },\n    };\n    const options = typeof optionsInput === 'function' ? optionsInput() : optionsInput;\n    const logOnly = options.logOnly\n        ? { pause: true, export: true, test: true }\n        : false;\n    const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n    const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n    }\n    return config;\n}\n\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n    constructor(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n}\nclass Refresh {\n    constructor() {\n        this.type = REFRESH;\n    }\n}\nclass Reset {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n}\nclass Rollback {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n}\nclass Commit {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n}\nclass Sweep {\n    constructor() {\n        this.type = SWEEP;\n    }\n}\nclass ToggleAction {\n    constructor(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n}\nclass SetActionsActive {\n    constructor(start, end, active = true) {\n        this.start = start;\n        this.end = end;\n        this.active = active;\n        this.type = SET_ACTIONS_ACTIVE;\n    }\n}\nclass JumpToState {\n    constructor(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n}\nclass JumpToAction {\n    constructor(actionId) {\n        this.actionId = actionId;\n        this.type = JUMP_TO_ACTION;\n    }\n}\nclass ImportState {\n    constructor(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n}\nclass LockChanges {\n    constructor(status) {\n        this.status = status;\n        this.type = LOCK_CHANGES;\n    }\n}\nclass PauseRecording {\n    constructor(status) {\n        this.status = status;\n        this.type = PAUSE_RECORDING;\n    }\n}\n\nfunction difference(first, second) {\n    return first.filter((item) => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n    const { computedStates, currentStateIndex } = liftedState;\n    // At start up NgRx dispatches init actions,\n    // When these init actions are being filtered out by the predicate or safe/block list options\n    // we don't have a complete computed states yet.\n    // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n    if (currentStateIndex >= computedStates.length) {\n        const { state } = computedStates[computedStates.length - 1];\n        return state;\n    }\n    const { state } = computedStates[currentStateIndex];\n    return state;\n}\nfunction unliftAction(liftedState) {\n    return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n    return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n    return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n        const idx = Number(actionIdx);\n        sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n        return sanitizedActions;\n    }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n    return Object.assign(Object.assign({}, action), { action: actionSanitizer(action.action, actionIdx) });\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n    return states.map((computedState, idx) => ({\n        state: sanitizeState(stateSanitizer, computedState.state, idx),\n        error: computedState.error,\n    }));\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n    return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n    return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n    const filteredStagedActionIds = [];\n    const filteredActionsById = {};\n    const filteredComputedStates = [];\n    liftedState.stagedActionIds.forEach((id, idx) => {\n        const liftedAction = liftedState.actionsById[id];\n        if (!liftedAction)\n            return;\n        if (idx &&\n            isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n            return;\n        }\n        filteredActionsById[id] = liftedAction;\n        filteredStagedActionIds.push(id);\n        filteredComputedStates.push(liftedState.computedStates[idx]);\n    });\n    return Object.assign(Object.assign({}, liftedState), { stagedActionIds: filteredStagedActionIds, actionsById: filteredActionsById, computedStates: filteredComputedStates });\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n    const predicateMatch = predicate && !predicate(state, action.action);\n    const safelistMatch = safelist &&\n        !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join('|'));\n    const blocklistMatch = blockedlist &&\n        action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join('|'));\n    return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nconst INIT_ACTION = { type: INIT };\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = { type: RECOMPUTE };\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n    if (error) {\n        return {\n            state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    let nextState = state;\n    let nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        errorHandler.handleError(err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    // If the recording is paused, recompute all states up until the pause state,\n    // else recompute all states.\n    const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n    for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n        const actionId = stagedActionIds[i];\n        const action = actionsById[actionId].action;\n        const previousEntry = nextComputedStates[i - 1];\n        const previousState = previousEntry ? previousEntry.state : committedState;\n        const previousError = previousEntry ? previousEntry.error : undefined;\n        const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        const entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n        nextComputedStates.push(entry);\n    }\n    // If the recording is paused, the last state will not be recomputed,\n    // because it's essentially not part of the state history.\n    if (isPaused) {\n        nextComputedStates.push(computedStates[computedStates.length - 1]);\n    }\n    return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n        isLocked: false,\n        isPaused: false,\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n    /**\n     * Manages how the history actions modify the history state.\n     */\n    return (reducer) => (liftedState, liftedAction) => {\n        let { monitorState, actionsById, nextActionId, stagedActionIds, skippedActionIds, committedState, currentStateIndex, computedStates, isLocked, isPaused, } = liftedState || initialLiftedState;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            let excess = n;\n            let idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (let i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter((id) => idsToDelete.indexOf(id) === -1);\n            stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n        }\n        // By default, aggressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        let minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case LOCK_CHANGES: {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case PAUSE_RECORDING: {\n                isPaused = liftedAction.status;\n                if (isPaused) {\n                    // Add a pause action to signal the devtools-user the recording is paused.\n                    // The corresponding state will be overwritten on each update to always contain\n                    // the latest state (see Actions.PERFORM_ACTION).\n                    stagedActionIds = [...stagedActionIds, nextActionId];\n                    actionsById[nextActionId] = new PerformAction({\n                        type: '@ngrx/devtools/pause',\n                    }, +Date.now());\n                    nextActionId++;\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n                    if (currentStateIndex === stagedActionIds.length - 2) {\n                        currentStateIndex++;\n                    }\n                    minInvalidatedStateIndex = Infinity;\n                }\n                else {\n                    commitChanges();\n                }\n                break;\n            }\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                commitChanges();\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { id: actionId } = liftedAction;\n                const index = skippedActionIds.indexOf(actionId);\n                if (index === -1) {\n                    skippedActionIds = [actionId, ...skippedActionIds];\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { start, end, active } = liftedAction;\n                const actionIds = [];\n                for (let i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = [...skippedActionIds, ...actionIds];\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case JUMP_TO_ACTION: {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n                const index = stagedActionIds.indexOf(liftedAction.actionId);\n                if (index !== -1)\n                    currentStateIndex = index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                    return liftedState || initialLiftedState;\n                }\n                if (isPaused ||\n                    (liftedState &&\n                        isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist))) {\n                    // If recording is paused or if the action should be ignored, overwrite the last state\n                    // (corresponds to the pause action) and keep everything else as is.\n                    // This way, the app gets the new current state while the devtools\n                    // do not record another action.\n                    const lastState = computedStates[computedStates.length - 1];\n                    computedStates = [\n                        ...computedStates.slice(0, -1),\n                        computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler),\n                    ];\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                const actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = [...stagedActionIds, actionId];\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                ({\n                    monitorState,\n                    actionsById,\n                    nextActionId,\n                    stagedActionIds,\n                    skippedActionIds,\n                    committedState,\n                    currentStateIndex,\n                    computedStates,\n                    isLocked,\n                    isPaused,\n                } = liftedAction.nextLiftedState);\n                break;\n            }\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            case UPDATE: {\n                const stateHasErrors = computedStates.filter((state) => state.error).length > 0;\n                if (stateHasErrors) {\n                    // Recompute all states\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                }\n                else {\n                    // If not paused/locked, add a new action to signal devtools-user\n                    // that there was a reducer update.\n                    if (!isPaused && !isLocked) {\n                        if (currentStateIndex === stagedActionIds.length - 1) {\n                            currentStateIndex++;\n                        }\n                        // Add a new action to only recompute state\n                        const actionId = nextActionId++;\n                        actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                        stagedActionIds = [...stagedActionIds, actionId];\n                        minInvalidatedStateIndex = stagedActionIds.length - 1;\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    }\n                    // Recompute state history with latest reducer and update action\n                    computedStates = computedStates.map((cmp) => (Object.assign(Object.assign({}, cmp), { state: reducer(cmp.state, RECOMPUTE_ACTION) })));\n                    currentStateIndex = stagedActionIds.length - 1;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                    }\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused,\n        };\n    };\n}\n\nclass DevtoolsDispatcher extends ActionsSubject {\n}\n/** @nocollapse */ /** @nocollapse */ DevtoolsDispatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsDispatcher, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ /** @nocollapse */ DevtoolsDispatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsDispatcher });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsDispatcher, decorators: [{\n            type: Injectable\n        }] });\n\nconst ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nclass DevtoolsExtension {\n    constructor(devtoolsExtension, config, dispatcher) {\n        this.config = config;\n        this.dispatcher = dispatcher;\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    notify(action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n        if (action.type === PERFORM_ACTION) {\n            if (state.isLocked || state.isPaused) {\n                return;\n            }\n            const currentState = unliftState(state);\n            if (shouldFilterActions(this.config) &&\n                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n                return;\n            }\n            const sanitizedState = this.config.stateSanitizer\n                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)\n                : currentState;\n            const sanitizedAction = this.config.actionSanitizer\n                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)\n                : action;\n            this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n        }\n        else {\n            // Requires full state update\n            const sanitizedLiftedState = Object.assign(Object.assign({}, state), { stagedActionIds: state.stagedActionIds, actionsById: this.config.actionSanitizer\n                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n                    : state.actionsById, computedStates: this.config.stateSanitizer\n                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n                    : state.computedStates });\n            this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n        }\n    }\n    createChangesObservable() {\n        if (!this.devtoolsExtension) {\n            return EMPTY;\n        }\n        return new Observable((subscriber) => {\n            const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n            this.extensionConnection = connection;\n            connection.init();\n            connection.subscribe((change) => subscriber.next(change));\n            return connection.unsubscribe;\n        });\n    }\n    createActionStreams() {\n        // Listens to all changes\n        const changes$ = this.createChangesObservable().pipe(share());\n        // Listen for the start action\n        const start$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.START));\n        // Listen for the stop action\n        const stop$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.STOP));\n        // Listen for lifted actions\n        const liftedActions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.DISPATCH), map((change) => this.unwrapAction(change.payload)), concatMap((action) => {\n            if (action.type === IMPORT_STATE) {\n                // State imports may happen in two situations:\n                // 1. Explicitly by user\n                // 2. User activated the \"persist state accross reloads\" option\n                //    and now the state is imported during reload.\n                // Because of option 2, we need to give possible\n                // lazy loaded reducers time to instantiate.\n                // As soon as there is no UPDATE action within 1 second,\n                // it is assumed that all reducers are loaded.\n                return this.dispatcher.pipe(filter((action) => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n            }\n            else {\n                return of(action);\n            }\n        }));\n        // Listen for unlifted actions\n        const actions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.ACTION), map((change) => this.unwrapAction(change.payload)));\n        const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$));\n        // Only take the action sources between the start/stop events\n        this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n        this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n    }\n    unwrapAction(action) {\n        return typeof action === 'string' ? eval(`(${action})`) : action;\n    }\n    getExtensionConfig(config) {\n        var _a;\n        const extensionOptions = {\n            name: config.name,\n            features: config.features,\n            serialize: config.serialize,\n            autoPause: (_a = config.autoPause) !== null && _a !== void 0 ? _a : false,\n            // The action/state sanitizers are not added to the config\n            // because sanitation is done in this class already.\n            // It is done before sending it to the devtools extension for consistency:\n            // - If we call extensionConnection.send(...),\n            //   the extension would call the sanitizers.\n            // - If we call devtoolsExtension.send(...) (aka full state update),\n            //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n        };\n        if (config.maxAge !== false /* support === 0 */) {\n            extensionOptions.maxAge = config.maxAge;\n        }\n        return extensionOptions;\n    }\n    sendToReduxDevtools(send) {\n        try {\n            send();\n        }\n        catch (err) {\n            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n    }\n}\n/** @nocollapse */ /** @nocollapse */ DevtoolsExtension.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsExtension, deps: [{ token: REDUX_DEVTOOLS_EXTENSION }, { token: STORE_DEVTOOLS_CONFIG }, { token: DevtoolsDispatcher }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ /** @nocollapse */ DevtoolsExtension.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsExtension });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: DevtoolsExtension, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [REDUX_DEVTOOLS_EXTENSION]\n                    }] }, { type: StoreDevtoolsConfig, decorators: [{\n                        type: Inject,\n                        args: [STORE_DEVTOOLS_CONFIG]\n                    }] }, { type: DevtoolsDispatcher }];\n    } });\n\nclass StoreDevtools {\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n        const liftedInitialState = liftInitialState(initialState, config.monitor);\n        const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n        const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n        const liftedReducer$ = reducers$.pipe(map(liftReducer));\n        const liftedStateSubject = new ReplaySubject(1);\n        const liftedStateSubscription = liftedAction$\n            .pipe(withLatestFrom(liftedReducer$), scan(({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n                reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n        }, { state: liftedInitialState, action: null }))\n            .subscribe(({ state, action }) => {\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                const unliftedAction = action.action;\n                scannedActions.next(unliftedAction);\n            }\n        });\n        const extensionStartSubscription = extension.start$.subscribe(() => {\n            this.refresh();\n        });\n        const liftedState$ = liftedStateSubject.asObservable();\n        const state$ = liftedState$.pipe(map(unliftState));\n        this.extensionStartSubscription = extensionStartSubscription;\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    dispatch(action) {\n        this.dispatcher.next(action);\n    }\n    next(action) {\n        this.dispatcher.next(action);\n    }\n    error(error) { }\n    complete() { }\n    performAction(action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    refresh() {\n        this.dispatch(new Refresh());\n    }\n    reset() {\n        this.dispatch(new Reset(+Date.now()));\n    }\n    rollback() {\n        this.dispatch(new Rollback(+Date.now()));\n    }\n    commit() {\n        this.dispatch(new Commit(+Date.now()));\n    }\n    sweep() {\n        this.dispatch(new Sweep());\n    }\n    toggleAction(id) {\n        this.dispatch(new ToggleAction(id));\n    }\n    jumpToAction(actionId) {\n        this.dispatch(new JumpToAction(actionId));\n    }\n    jumpToState(index) {\n        this.dispatch(new JumpToState(index));\n    }\n    importState(nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    }\n    lockChanges(status) {\n        this.dispatch(new LockChanges(status));\n    }\n    pauseRecording(status) {\n        this.dispatch(new PauseRecording(status));\n    }\n}\n/** @nocollapse */ /** @nocollapse */ StoreDevtools.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtools, deps: [{ token: DevtoolsDispatcher }, { token: i2.ActionsSubject }, { token: i2.ReducerObservable }, { token: DevtoolsExtension }, { token: i2.ScannedActionsSubject }, { token: i0.ErrorHandler }, { token: INITIAL_STATE }, { token: STORE_DEVTOOLS_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ /** @nocollapse */ StoreDevtools.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtools });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtools, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: DevtoolsDispatcher }, { type: i2.ActionsSubject }, { type: i2.ReducerObservable }, { type: DevtoolsExtension }, { type: i2.ScannedActionsSubject }, { type: i0.ErrorHandler }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [INITIAL_STATE]\n                    }] }, { type: StoreDevtoolsConfig, decorators: [{\n                        type: Inject,\n                        args: [STORE_DEVTOOLS_CONFIG]\n                    }] }];\n    } });\n\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n    const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof window[extensionKey] !== 'undefined') {\n        return window[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\nclass StoreDevtoolsModule {\n    static instrument(options = {}) {\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    }\n}\n/** @nocollapse */ /** @nocollapse */ StoreDevtoolsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtoolsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ /** @nocollapse */ StoreDevtoolsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtoolsModule });\n/** @nocollapse */ /** @nocollapse */ StoreDevtoolsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtoolsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.0\", ngImport: i0, type: StoreDevtoolsModule, decorators: [{\n            type: NgModule,\n            args: [{}]\n        }] });\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, REDUX_DEVTOOLS_EXTENSION, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule };\n"]},"metadata":{},"sourceType":"module"}